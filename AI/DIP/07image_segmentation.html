<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>图像分割 | Snake8859</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/snake.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="Snake8859的文档和个人笔记">
    <link rel="preload" href="/assets/css/0.styles.096ead02.css" as="style"><link rel="preload" href="/assets/js/app.02e74a2b.js" as="script"><link rel="preload" href="/assets/js/2.57c6d2f7.js" as="script"><link rel="preload" href="/assets/js/13.41791305.js" as="script"><link rel="prefetch" href="/assets/js/10.c2699515.js"><link rel="prefetch" href="/assets/js/100.e57e7729.js"><link rel="prefetch" href="/assets/js/101.baa01a63.js"><link rel="prefetch" href="/assets/js/102.1453dcb5.js"><link rel="prefetch" href="/assets/js/103.48c119dd.js"><link rel="prefetch" href="/assets/js/104.550d240d.js"><link rel="prefetch" href="/assets/js/105.b1180861.js"><link rel="prefetch" href="/assets/js/106.c5ccb84e.js"><link rel="prefetch" href="/assets/js/107.9682dff2.js"><link rel="prefetch" href="/assets/js/108.f1e82505.js"><link rel="prefetch" href="/assets/js/109.3598962f.js"><link rel="prefetch" href="/assets/js/11.53f16f31.js"><link rel="prefetch" href="/assets/js/110.15fe31e1.js"><link rel="prefetch" href="/assets/js/111.a0b10664.js"><link rel="prefetch" href="/assets/js/112.d3939d20.js"><link rel="prefetch" href="/assets/js/113.46e4835a.js"><link rel="prefetch" href="/assets/js/114.e55e2fb3.js"><link rel="prefetch" href="/assets/js/115.e06faf79.js"><link rel="prefetch" href="/assets/js/12.3c132a0b.js"><link rel="prefetch" href="/assets/js/14.cc4eaec7.js"><link rel="prefetch" href="/assets/js/15.4f4f189f.js"><link rel="prefetch" href="/assets/js/16.af6aed74.js"><link rel="prefetch" href="/assets/js/17.c8762897.js"><link rel="prefetch" href="/assets/js/18.c5dc67b3.js"><link rel="prefetch" href="/assets/js/19.86d202ed.js"><link rel="prefetch" href="/assets/js/20.e4189130.js"><link rel="prefetch" href="/assets/js/21.c7811963.js"><link rel="prefetch" href="/assets/js/22.d82eb4ed.js"><link rel="prefetch" href="/assets/js/23.5548e03a.js"><link rel="prefetch" href="/assets/js/24.8aad1281.js"><link rel="prefetch" href="/assets/js/25.356cd371.js"><link rel="prefetch" href="/assets/js/26.0a3dcd9a.js"><link rel="prefetch" href="/assets/js/27.08050082.js"><link rel="prefetch" href="/assets/js/28.fb22042e.js"><link rel="prefetch" href="/assets/js/29.03fccaf0.js"><link rel="prefetch" href="/assets/js/3.bde541ac.js"><link rel="prefetch" href="/assets/js/30.60a56dab.js"><link rel="prefetch" href="/assets/js/31.987d12a2.js"><link rel="prefetch" href="/assets/js/32.1adb2c8c.js"><link rel="prefetch" href="/assets/js/33.2108f876.js"><link rel="prefetch" href="/assets/js/34.cb778d11.js"><link rel="prefetch" href="/assets/js/35.bbf509e8.js"><link rel="prefetch" href="/assets/js/36.4378233a.js"><link rel="prefetch" href="/assets/js/37.0ae1fe21.js"><link rel="prefetch" href="/assets/js/38.51659462.js"><link rel="prefetch" href="/assets/js/39.26983312.js"><link rel="prefetch" href="/assets/js/4.de92bf2f.js"><link rel="prefetch" href="/assets/js/40.e7ac011c.js"><link rel="prefetch" href="/assets/js/41.b38b59a9.js"><link rel="prefetch" href="/assets/js/42.f13536bc.js"><link rel="prefetch" href="/assets/js/43.20016372.js"><link rel="prefetch" href="/assets/js/44.df5cefde.js"><link rel="prefetch" href="/assets/js/45.7f2bd9f7.js"><link rel="prefetch" href="/assets/js/46.6572ecd2.js"><link rel="prefetch" href="/assets/js/47.29c01931.js"><link rel="prefetch" href="/assets/js/48.c5d50761.js"><link rel="prefetch" href="/assets/js/49.eedeb413.js"><link rel="prefetch" href="/assets/js/5.d35fae6e.js"><link rel="prefetch" href="/assets/js/50.668aed89.js"><link rel="prefetch" href="/assets/js/51.fabbb73f.js"><link rel="prefetch" href="/assets/js/52.40199eb6.js"><link rel="prefetch" href="/assets/js/53.04341370.js"><link rel="prefetch" href="/assets/js/54.1ea7a647.js"><link rel="prefetch" href="/assets/js/55.d9a29e16.js"><link rel="prefetch" href="/assets/js/56.5a212b0d.js"><link rel="prefetch" href="/assets/js/57.557b132e.js"><link rel="prefetch" href="/assets/js/58.57f63c23.js"><link rel="prefetch" href="/assets/js/59.f9868ad9.js"><link rel="prefetch" href="/assets/js/6.cbbecb9e.js"><link rel="prefetch" href="/assets/js/60.d715511d.js"><link rel="prefetch" href="/assets/js/61.94f23e53.js"><link rel="prefetch" href="/assets/js/62.b9d0cd87.js"><link rel="prefetch" href="/assets/js/63.430b0804.js"><link rel="prefetch" href="/assets/js/64.64115894.js"><link rel="prefetch" href="/assets/js/65.862c29a4.js"><link rel="prefetch" href="/assets/js/66.1d742c87.js"><link rel="prefetch" href="/assets/js/67.85f2fac8.js"><link rel="prefetch" href="/assets/js/68.5433d095.js"><link rel="prefetch" href="/assets/js/69.4e1e27a1.js"><link rel="prefetch" href="/assets/js/7.58204c03.js"><link rel="prefetch" href="/assets/js/70.5ea3a9d1.js"><link rel="prefetch" href="/assets/js/71.76670aca.js"><link rel="prefetch" href="/assets/js/72.709e8ea7.js"><link rel="prefetch" href="/assets/js/73.36be2c03.js"><link rel="prefetch" href="/assets/js/74.3846c884.js"><link rel="prefetch" href="/assets/js/75.7645483b.js"><link rel="prefetch" href="/assets/js/76.fd3c307b.js"><link rel="prefetch" href="/assets/js/77.7be1ab20.js"><link rel="prefetch" href="/assets/js/78.32ab0068.js"><link rel="prefetch" href="/assets/js/79.efbbf8ab.js"><link rel="prefetch" href="/assets/js/8.abd032fa.js"><link rel="prefetch" href="/assets/js/80.9f10b4c0.js"><link rel="prefetch" href="/assets/js/81.451f32ee.js"><link rel="prefetch" href="/assets/js/82.722cb36d.js"><link rel="prefetch" href="/assets/js/83.f9528af6.js"><link rel="prefetch" href="/assets/js/84.47c73bff.js"><link rel="prefetch" href="/assets/js/85.b01e8c4a.js"><link rel="prefetch" href="/assets/js/86.c88eff6b.js"><link rel="prefetch" href="/assets/js/87.870c1ca3.js"><link rel="prefetch" href="/assets/js/88.1096db0d.js"><link rel="prefetch" href="/assets/js/89.9cc7fb66.js"><link rel="prefetch" href="/assets/js/9.5bf26188.js"><link rel="prefetch" href="/assets/js/90.e1df3db6.js"><link rel="prefetch" href="/assets/js/91.b58c4d10.js"><link rel="prefetch" href="/assets/js/92.f969419b.js"><link rel="prefetch" href="/assets/js/93.8490ac72.js"><link rel="prefetch" href="/assets/js/94.7d04723c.js"><link rel="prefetch" href="/assets/js/95.953295d7.js"><link rel="prefetch" href="/assets/js/96.4523f191.js"><link rel="prefetch" href="/assets/js/97.1f861b1b.js"><link rel="prefetch" href="/assets/js/98.86252b38.js"><link rel="prefetch" href="/assets/js/99.6c922fe1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.096ead02.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Snake8859</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专业" class="dropdown-title"><span class="title">专业</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          地信
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Introduction/" class="nav-link">
  地信导论和原理
</a></li><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Operation/" class="nav-link">
  地信软件操作
</a></li><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Programming/" class="nav-link">
  地信编程
</a></li><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Resources/" class="nav-link">
  地信资源
</a></li></ul></li><li class="dropdown-item"><h4>
          遥感
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Major/RS/RS_Introduction/" class="nav-link">
  遥感导论和原理
</a></li><li class="dropdown-subitem"><a href="/Major/RS/RS_Operation/" class="nav-link">
  遥感软件操作
</a></li><li class="dropdown-subitem"><a href="/Major/RS/RS_Programming/" class="nav-link">
  遥感编程
</a></li><li class="dropdown-subitem"><a href="/Major/RS/RS_Resources/" class="nav-link">
  遥感资源
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><span class="title">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/FrontEnd/HTML_CSS_JS/" class="nav-link">
  HTML/CSS/JS
</a></li><li class="dropdown-subitem"><a href="/FrontEnd/Vuejs/" class="nav-link">
  Vuejs/Dojo
</a></li><li class="dropdown-subitem"><a href="/FrontEnd/Nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/FrontEnd/MiniProgram/" class="nav-link">
  微信小程序
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/BackEnd/Java/" class="nav-link">
  Java
</a></li><li class="dropdown-subitem"><a href="/BackEnd/DataBase/" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/BackEnd/WebServer/" class="nav-link">
  Web服务器
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/AI/Python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/EnvsAndTools/" class="nav-link">
  开发环境与工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="研究" class="dropdown-title"><span class="title">研究</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/AI/DIP/" class="nav-link router-link-active">
  数字图像处理
</a></li><li class="dropdown-item"><!----> <a href="/AI/PR/" class="nav-link">
  模式识别导论
</a></li><li class="dropdown-item"><!----> <a href="/AI/MachineLearning/" class="nav-link">
  机器学习
</a></li><li class="dropdown-item"><!----> <a href="/AI/DeepLearning/" class="nav-link">
  深度学习
</a></li></ul></div></div><div class="nav-item"><a href="/LifeAndTC/" class="nav-link">
  生活与吐槽
</a></div><div class="nav-item"><a href="/About/" class="nav-link">
  关于
</a></div> <a href="https://github.com/Snake8859/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专业" class="dropdown-title"><span class="title">专业</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          地信
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Introduction/" class="nav-link">
  地信导论和原理
</a></li><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Operation/" class="nav-link">
  地信软件操作
</a></li><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Programming/" class="nav-link">
  地信编程
</a></li><li class="dropdown-subitem"><a href="/Major/GIS/GIS_Resources/" class="nav-link">
  地信资源
</a></li></ul></li><li class="dropdown-item"><h4>
          遥感
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Major/RS/RS_Introduction/" class="nav-link">
  遥感导论和原理
</a></li><li class="dropdown-subitem"><a href="/Major/RS/RS_Operation/" class="nav-link">
  遥感软件操作
</a></li><li class="dropdown-subitem"><a href="/Major/RS/RS_Programming/" class="nav-link">
  遥感编程
</a></li><li class="dropdown-subitem"><a href="/Major/RS/RS_Resources/" class="nav-link">
  遥感资源
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发" class="dropdown-title"><span class="title">开发</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/FrontEnd/HTML_CSS_JS/" class="nav-link">
  HTML/CSS/JS
</a></li><li class="dropdown-subitem"><a href="/FrontEnd/Vuejs/" class="nav-link">
  Vuejs/Dojo
</a></li><li class="dropdown-subitem"><a href="/FrontEnd/Nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/FrontEnd/MiniProgram/" class="nav-link">
  微信小程序
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/BackEnd/Java/" class="nav-link">
  Java
</a></li><li class="dropdown-subitem"><a href="/BackEnd/DataBase/" class="nav-link">
  数据库
</a></li><li class="dropdown-subitem"><a href="/BackEnd/WebServer/" class="nav-link">
  Web服务器
</a></li></ul></li><li class="dropdown-item"><!----> <a href="/AI/Python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/EnvsAndTools/" class="nav-link">
  开发环境与工具
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="研究" class="dropdown-title"><span class="title">研究</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/AI/DIP/" class="nav-link router-link-active">
  数字图像处理
</a></li><li class="dropdown-item"><!----> <a href="/AI/PR/" class="nav-link">
  模式识别导论
</a></li><li class="dropdown-item"><!----> <a href="/AI/MachineLearning/" class="nav-link">
  机器学习
</a></li><li class="dropdown-item"><!----> <a href="/AI/DeepLearning/" class="nav-link">
  深度学习
</a></li></ul></div></div><div class="nav-item"><a href="/LifeAndTC/" class="nav-link">
  生活与吐槽
</a></div><div class="nav-item"><a href="/About/" class="nav-link">
  关于
</a></div> <a href="https://github.com/Snake8859/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数字图像处理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/AI/DIP/" class="sidebar-link">数字图像处理笔记</a></li><li><a href="/AI/DIP/01vision_image.html" class="sidebar-link">视觉与图像</a></li><li><a href="/AI/DIP/02image_base.html" class="sidebar-link">图像基本知识</a></li><li><a href="/AI/DIP/03image_transformation.html" class="sidebar-link">图像变换</a></li><li><a href="/AI/DIP/04image_enhancement.html" class="sidebar-link">图像增强</a></li><li><a href="/AI/DIP/05image_description.html" class="sidebar-link">图像的矩阵，空间和统计描述</a></li><li><a href="/AI/DIP/06image_morphology.html" class="sidebar-link">图像形态学处理</a></li><li><a href="/AI/DIP/07image_segmentation.html" class="active sidebar-link">图像分割</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#预备知识" class="sidebar-link">预备知识</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#奇异性检测" class="sidebar-link">奇异性检测</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#点检测" class="sidebar-link">点检测</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#线检测" class="sidebar-link">线检测</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#边缘检测" class="sidebar-link">边缘检测</a></li></ul></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#边缘连接和边界检测" class="sidebar-link">边缘连接和边界检测</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#局部处理" class="sidebar-link">局部处理</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#区域处理" class="sidebar-link">区域处理</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#整体处理（霍夫变换）" class="sidebar-link">整体处理（霍夫变换）</a></li></ul></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#阈值处理" class="sidebar-link">阈值处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#基础" class="sidebar-link">基础</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#基本全局阈值处理" class="sidebar-link">基本全局阈值处理</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#最佳全局阈值处理" class="sidebar-link">最佳全局阈值处理</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#图像平滑改善全局阈值处理" class="sidebar-link">图像平滑改善全局阈值处理</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#基本自适应阈值" class="sidebar-link">基本自适应阈值</a></li></ul></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#基于区域的分割" class="sidebar-link">基于区域的分割</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#区域生长" class="sidebar-link">区域生长</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#四叉树分解" class="sidebar-link">四叉树分解</a></li></ul></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#用形态学分水岭的分割" class="sidebar-link">用形态学分水岭的分割</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#水坝构建" class="sidebar-link">水坝构建</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#分水岭分割算法" class="sidebar-link">分水岭分割算法</a></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#标记的使用" class="sidebar-link">标记的使用</a></li></ul></li><li class="sidebar-sub-header"><a href="/AI/DIP/07image_segmentation.html#基于pde（偏微分方程）的图像分割" class="sidebar-link">基于PDE（偏微分方程）的图像分割</a></li></ul></li><li><a href="/AI/DIP/08wavelet_transform.html" class="sidebar-link">小波变换</a></li><li><a href="/AI/DIP/09image_restoration.html" class="sidebar-link">图像复原与重建</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="图像分割"><a href="#图像分割" class="header-anchor">#</a> 图像分割</h1> <h2 id="预备知识"><a href="#预备知识" class="header-anchor">#</a> 预备知识</h2> <p>图像分割的定义：</p> <img src="07image_segmentation.assets/image-20201113153050863.png" alt="image-20201113153050863" style="zoom:67%;"> <blockquote><ul><li>在对图像的研究和应用中，人们往往仅对图像中的某些部分感兴趣，这些部分一般称为目标或前景</li> <li>为了辨识和分析目标，需要将有关区域分离并提取出来，在此基础上对目标进一步利用，如进行特征提取、测量或识别</li> <li>图像分割就是指把图像分成各具同一特性的区域并提取出感兴趣目标的技术和过程</li> <li>特性可以是灰度、颜色、纹理等，目标可以对应单个区域，也可以对应多个区域</li> <li>图像分割算法是基于图像特性的不连续性和相似性</li> <li>不连续性是基于图像特性的不连续变化分割图像，如 图像的边缘</li> <li>根据图像特性的规则将图像分割为相似的区域，如阈值处理、区域生长、区域分离和聚合</li></ul> <p>图像分割是指根据灰度、彩色、空间纹理、几何形状等特征把图像划分成若干个互不相交的区域，使得这些特征在同一区域内表现出一致性或相似性，而在不同区域间表现出明显的不同。</p> <p><strong>简单的说就是在一副图像中，把目标从背景中分离出来。对于灰度图像来说，区域内部的像素一般具有灰度相似性，而在区域的边界上一般具有灰度不连续性</strong></p></blockquote> <p>三大类方法：</p> <ul><li>根据区域间灰度不连续搜寻区域之间的边界，在奇异性检测、边缘连接和边界检测介绍</li> <li>以像素性质的分布进行阈值处理，在阈值处理介绍</li> <li>直接搜寻区域进行分割，在基于区域的分割中介绍</li></ul> <h2 id="奇异性检测"><a href="#奇异性检测" class="header-anchor">#</a> 奇异性检测</h2> <p><strong>图像的奇异性指的是图像局部信息的光滑程度，一般情况下绝大多数图像区域是平滑的，少数不平滑。由于图像是二维的，不平滑的信息有孤立点、线和边缘</strong></p> <h3 id="点检测"><a href="#点检测" class="header-anchor">#</a> 点检测</h3> <p>使用模板，与图像进行卷积，若模板计算值R大于阈值T，则检测到一个点。</p> <img src="07image_segmentation.assets/image-20201113153432144.png" alt="image-20201113153432144" style="zoom:67%;"> <p><strong>基本思想：如果一个孤立点与它周围的点不同，则可以使用上述模板进行检测。</strong></p> <p><strong>注意：如果模板响应为0，则表示在灰度级为常数的区域</strong></p> <img src="07image_segmentation.assets/image-20201113153603537.png" alt="image-20201113153603537" style="zoom:67%;"> <blockquote><p>连续小波变换可以精确检测奇异性，单靠模板无法做教精确检测。</p></blockquote> <h3 id="线检测"><a href="#线检测" class="header-anchor">#</a> 线检测</h3> <p>与点检测类似，不过使用专门的线检测模板。</p> <img src="07image_segmentation.assets/image-20201113153755082.png" alt="image-20201113153755082" style="zoom:67%;"> <ul><li>第一个模板对水平线有最大响应</li> <li>第二模板对45°方向线有最大响应</li> <li>第三模板对垂直线有最大响应</li> <li>第四模板对-45°方向线有最大响应</li></ul> <blockquote><p>小角度线检测模板如何设计，如15°</p></blockquote> <h3 id="边缘检测"><a href="#边缘检测" class="header-anchor">#</a> 边缘检测</h3> <p>边缘检测是基于灰度突变来分割图像的常用方法。</p> <h4 id="图像梯度及其性质"><a href="#图像梯度及其性质" class="header-anchor">#</a> <strong>图像梯度及其性质</strong></h4> <p>为了在一幅图像<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>位置处寻找边缘的强度和方向，所选择的工具就是梯度，梯度用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">▽</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\triangledown f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">▽</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>来表示，并用向量来定义：</p> <p><img src="07image_segmentation.assets/image-20201211224540179-1609933621742.png" alt="image-20201211224540179"></p> <p>这个梯度向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">▽</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\triangledown f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">▽</span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>在点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>处的幅度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">M(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>由其欧几里得向量范数得到：</p> <p><img src="07image_segmentation.assets/image-20201211224745732-1609933623322.png" alt="image-20201211224745732"></p> <blockquote><p>它是点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>处的方向变化率的值。</p></blockquote> <p>梯度向量在点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>处的方向由下式给出：</p> <p><img src="07image_segmentation.assets/image-20201211224911204.png" alt="image-20201211224911204"></p> <blockquote><p>角度是相对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>轴逆时针方向度量的。</p></blockquote> <p>注意，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>g</mi><mi>y</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">▽</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>M</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>a</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g_x,g_y,||\triangledown f(x,y)||,M(x,y),a(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">∣</span><span class="mord mathrm">∣</span><span class="mord mathrm">▽</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathrm">∣</span><span class="mord mathrm">∣</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>都是与原图像<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span>大小相同的矩阵。一般通常称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">M(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>为梯度图像，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>是方向图像。</p> <img src="07image_segmentation.assets/image-20201113160550835.png" alt="image-20201113160550835" style="zoom:67%;"> <blockquote><p>案例（梯度性质）</p> <img src="07image_segmentation.assets/image-20201211225228034.png" alt="image-20201211225228034" style="zoom:67%;"> <p>梯度向量有时候也称为边缘发线，因为它与边缘方向是正交的。</p></blockquote> <h4 id="边缘模型"><a href="#边缘模型" class="header-anchor">#</a> <strong>边缘模型</strong></h4> <p>边缘模型根据它们的灰度剖面来分类。有台阶边缘、斜坡边缘和 “屋顶”边缘。</p> <img src="07image_segmentation.assets/image-20201113155409434.png" alt="image-20201113155409434" style="zoom:67%;"> <p>一阶导数的幅度可用于检测图像中的某个点处是否存在一个边缘。</p> <p>二阶导数的符号用于确定一个边缘像素是位于该边缘的暗侧还是位于该边缘的亮侧。</p> <p>围绕一条边缘的二阶导数的两个附加性质：</p> <ul><li>对图像中的每条边缘，二阶导数生成两个值（一个不希望的特点）</li> <li>二阶导数的零交叉点可用于定位粗边缘的中心</li></ul> <img src="07image_segmentation.assets/image-20201113155634557.png" alt="image-20201113155634557" style="zoom:67%;"> <blockquote><p>微弱的可见噪声严重影响检测边缘所用的两个关键导数。</p> <img src="07image_segmentation.assets/image-20201113155726387.png" alt="image-20201113155726387" style="zoom:67%;"> <p>因为噪声是变化尖锐的地方，求导之后其导数的绝对值很突兀。</p></blockquote> <p>因此执行边缘检测的三个基本步骤是：</p> <ol><li>为降噪图像进行平滑处理</li> <li>边缘点的检测。这是一个局部操作，从一幅图像中提取所有边缘点的潜在候选者</li> <li>边缘定位。这一步的目的是从候选边缘点中选择组成边缘点集合的真实成员</li></ol> <h4 id="基本边缘检测算子"><a href="#基本边缘检测算子" class="header-anchor">#</a> <strong>基本边缘检测</strong>算子</h4> <h5 id="roberts交叉算子"><a href="#roberts交叉算子" class="header-anchor">#</a> Roberts交叉算子</h5> <p>Robert是利用局部差分算子寻找边缘算子。其卷积核分别为：</p> <p><img src="07image_segmentation.assets/image-20201211225529798-1609933659176.png" alt="image-20201211225529798"></p> <p>采用1范数衡量梯度的幅度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>G</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>x</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>y</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|G(x,y)|=|G_x|+|G_y|</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∣</span><span class="mord mathit">G</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathrm">∣</span><span class="mrel">=</span><span class="mord mathrm">∣</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">x</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">∣</span><span class="mbin">+</span><span class="mord mathrm">∣</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">∣</span></span></span></span></p> <p>作用：对于具有<strong>陡峭</strong>的<strong>低噪声</strong>的图像效果较高。</p> <h5 id="sobel算子"><a href="#sobel算子" class="header-anchor">#</a> Sobel算子</h5> <p>Sobel算子，采用中心对称的核，并考试中心点对侧数据的性质，并带有关于边缘方向的更多信息。其卷积核分别为</p> <p><img src="07image_segmentation.assets/image-20201211225808823-1609933660770.png" alt="image-20201211225808823"></p> <p>采用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>范数衡量梯度的幅度|G(x,y)|≈max(|G_x|,|G_y|)</p> <p>作用：对于<strong>灰度渐变</strong>和<strong>噪声较多</strong>的图像处理较好。</p> <blockquote><p>其中心位置使用2权重，通过强调中心位置来对图像进行平滑。</p></blockquote> <h5 id="prewitt算子"><a href="#prewitt算子" class="header-anchor">#</a> Prewitt算子</h5> <p>Prewitt算子和Sobel算子类似，不同之处仅在其中心位置使用1权重。其卷积核分别为：</p> <p><img src="07image_segmentation.assets/image-20201211230442245-1609933662537.png" alt="image-20201211230442245"></p> <p>作用：对于<strong>灰度渐变</strong>和<strong>噪声较多</strong>的图像处理较好。</p> <h5 id="canny算子（重点）"><a href="#canny算子（重点）" class="header-anchor">#</a> Canny算子（重点）</h5> <p>Canny算子的梯度是用高斯滤波器的导数计算的，检测边缘的方法是寻找图像梯度的局部极大值。</p> <p>算法步骤：</p> <ol><li><p><strong>用高斯滤波器平滑图像；</strong></p> <blockquote><img src="07image_segmentation.assets/image-20201211230602843.png" alt="image-20201211230602843" style="zoom:80%;"></blockquote></li> <li><p><strong>计算滤波后图像梯度的幅值和方向；</strong></p> <blockquote><p>使用上方介绍的任意一个梯度算子，来计算梯度幅度和方向。</p> <p><img src="07image_segmentation.assets/image-20201211230724495-1609933669640.png" alt="image-20201211230724495"></p></blockquote></li> <li><p><strong>对梯度幅值应用非极大值抑制。其过程为找出图像梯度中的局部极大值点，把其他非局部极大值点置零以得到细化的边缘；</strong></p> <blockquote><p>PPT介绍：</p> <ul><li><p>非极大值抑制：沿幅角方向检测模值的极大值点，即边缘点，遍历8个方向图像像素，把每个像素偏导值与相邻像素的模值比较，取其MAX值为边缘点，置像素灰度值为0。</p> <img src="07image_segmentation.assets/image-20201114110436732.png" alt="image-20201114110436732" style="zoom:67%;"></li></ul> <p>课本介绍：</p> <img src="07image_segmentation.assets/image-20201211231039965.png" alt="image-20201211231039965" style="zoom:80%;"> <img src="07image_segmentation.assets/image-20201211231119567.png" alt="image-20201211231119567" style="zoom:80%;"></blockquote></li> <li><p><strong>双阈值算法检测和连续边缘。使用两个阈值T1和T2（T1&gt;T2），T1用来找到每条线段，T2用来在这些线段的两个方向上延伸寻找边缘的断裂处，并连接这些边缘。其中T1代表大于该值的肯定是边缘，T2表示小于该值的肯定不是边缘。</strong></p> <blockquote><p>双阈值检测：由于单阈值处理时，合适的阈值选择较困难，常常需要采用反复试验，因此采用双阈值检测算法。</p> <ul><li>对经过非极大值抑制后的图像作用两个阈值th1，th2，th1=0.4th2,两个阈值作用后得到两个图像1、2。</li> <li>较大阈值检测出的图像2去除了大部分噪声，但是也损失了有用的边缘信息。</li> <li>较小阈值检测得到的图像1则保留着较多的边缘信息，以此为基础，补充图像2中的丢失的信息，连接图像边缘。</li></ul> <p>连接边缘：</p> <ol><li>对图像2进行扫描，当遇到一个非零灰度的像素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>时，跟踪以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>为开始点的轮廓线，直到轮廓线的终点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。</li> <li>考察图像1中与图像2中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>点位置对应的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的8邻近区域。如果在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>中的8邻近区域中有非零像素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>存在，则将其包括到图像2中，作为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">r(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>点。从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">r(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>开始，重复第一步，直到我们图像1和图像2中都无法继续为止。</li> <li>当完成对包括<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的轮廓线的连结之后，将这条轮廓线标记为已经访问。回到第一步，寻找下一条轮廓线。重复第一步，第二，第三步，直到图像2中找不到新轮廓线为止。</li></ol> <p>即图像2在图像1中生长。</p></blockquote></li></ol> <img src="07image_segmentation.assets/image-20201114113913558.png" alt="image-20201114113913558" style="zoom:67%;"> <p><strong>坎尼边缘检测算法的步骤小结如下：</strong></p> <ol><li><strong>使用高斯滤波器平滑图像</strong></li> <li><strong>利用微分算子，计算梯度幅值和方向图像</strong></li> <li><strong>对梯度幅值图像进行非极大值抑制</strong></li> <li><strong>用双阈值处理和连通性分析来检测与连接边缘。</strong></li></ol> <h5 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="header-anchor">#</a> 拉普拉斯算子</h5> <p>拉普拉斯（Laplace）算子是离散二维二阶导数的最简单形式。</p> <img src="07image_segmentation.assets/image-20201211232427001.png" alt="image-20201211232427001" style="zoom:67%;"> <h5 id="拉普拉斯-高斯算子"><a href="#拉普拉斯-高斯算子" class="header-anchor">#</a> 拉普拉斯-高斯算子</h5> <p>基本思想：由于拉普拉斯算子对于噪声比较敏感，因此采用先用高斯函数对图像滤波，然后对滤波后的图像进行拉普拉斯运算，算得的值等于零的点认为是边界点。</p> <p>过程：</p> <ul><li>用一个2-D的高斯平滑模板与源图象卷积</li> <li>计算卷积后图象的拉普拉斯值</li> <li>检测拉普拉斯图象中的过零点作为边缘点</li></ul> <h4 id="各种边缘检测算子比较"><a href="#各种边缘检测算子比较" class="header-anchor">#</a> 各种边缘检测算子比较</h4> <ul><li><p>Roberts算子：利用局部差分算子寻找边缘，边缘定位精度较高，但容易丢失一部分边缘，同时由于图像没经过平滑处理，因此不具备抑制噪声能力。</p> <blockquote><p>该算子用于具有陡峭边缘且噪声低的图像效果较好。</p></blockquote></li> <li><p>Sobel算子和Prewitt算子：都是对图像先作加权平滑处理，然后再作微分运算，所不同的是平滑部分的权值有些差异，因此对噪声具有一定的抑制能力，但不能完全排除检测结果中出现的虚假边缘。</p> <blockquote><p>虽然这两个算子边缘定位效果不错，但检测出的边缘容易出现多像素宽度。</p></blockquote></li> <li><p>Laplacian算子：是不依赖于边缘方向的二阶微分算子，对图像中的阶跃型边缘点定位准确，该算子对噪声非常敏感，它使噪声成分得到加强，这两个特性使得该算子容易丢失一部分边缘的方向信息，造成一些不连续的检测边缘，同时抗噪声能力比较差。</p></li> <li><p>LOG算子：该算子克服了Laplacian算子抗噪声能力比较差的缺点，但在抑制噪声的同时也可能将原有的比较尖锐的边缘也平滑掉了，造成这些尖锐边缘无法被检测到。</p></li></ul> <h2 id="边缘连接和边界检测"><a href="#边缘连接和边界检测" class="header-anchor">#</a> 边缘连接和边界检测</h2> <p>理想情况下，边缘检测应该仅产生位于边缘上的像素集合。实际上，由于噪声、不均匀照明引起的<strong>边缘间断</strong>，以及其他引入灰度值虚假的不连续的影响，这些像素并不能完全描述边缘特性。</p> <p>因此，一般是在边缘检测后紧跟连接算法，将边缘像素组合成有意义的边缘或区域边界。</p> <p>三种基本的边缘连接方法：</p> <ul><li>第一种方法需要有关局部区域中的边缘点（如一个3×3邻域）的知识；</li> <li>第二种方法要求区域边界上的点已知；</li> <li>第三种方法是处理整个边缘图像的全局方法。</li></ul> <h3 id="局部处理"><a href="#局部处理" class="header-anchor">#</a> 局部处理</h3> <p>在每个点 (𝑥, 𝑦) 处的一个小邻域内分析像素的特点，根据预定的准则， 将所有的相似点连接起来，以形成根据指定准则满足相同特性像素的 一条边缘。</p> <p>步骤：</p> <img src="07image_segmentation.assets/image-20201114115239712.png" alt="image-20201114115239712" style="zoom:67%;"> <img src="图像处理.assets/image-20201114115402328.png" alt="image-20201114115402328" style="zoom:67%;"> <h3 id="区域处理"><a href="#区域处理" class="header-anchor">#</a> 区域处理</h3> <p>对这类处理的一种方法是函数近似，我们对已知点拟合一条二维曲线。我们的兴趣通常在于快速执行的技术，多边形近似尤其有吸引力</p> <img src="07image_segmentation.assets/image-20201114115642090.png" alt="image-20201114115642090" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114115707646.png" alt="image-20201114115707646" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114115724156.png" alt="image-20201114115724156" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114115707646-1609933697948.png" alt="image-20201114115707646" style="zoom:67%;"> <h3 id="整体处理（霍夫变换）"><a href="#整体处理（霍夫变换）" class="header-anchor">#</a> 整体处理（霍夫变换）</h3> <p>检测像素是否位于指定形状的曲线上。一旦检测到，这些曲线就会形 成边缘或感兴趣的区域边界。</p> <blockquote><img src="07image_segmentation.assets/image-20201114115837164.png" alt="image-20201114115837164" style="zoom:67%;"></blockquote> <p>霍夫变换是一种替代方法：从图像的xy平面到参数空间。</p> <p>基本思想：</p> <ul><li><p>对于边界上的n个点的点集，找出共线的点集和直线方程</p></li> <li><p>对于任意两点的直线方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = ax + b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span></span></span></span>，构造一个参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span></span></span></span>的平面，从而有如下结论：</p> <ul><li><p>xy平面上的任意一条直线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = ax + b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span></span></span></span>，对应在参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span></span></span></span>平面上都有一个点</p></li> <li><p>过xy平面一个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的所有直线，构成参数ab平面上的一条直线</p> <img src="07image_segmentation.assets/image-20201114115910808.png" alt="image-20201114115910808" style="zoom:67%;"></li></ul></li> <li><p>如果点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x1,y1)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>与点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x2,y2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span>共线，那么这两点在参数ab平面上的直线将有一个交点。</p></li> <li><p>在参数ab平面上相交直线最多的点，对应的xy平面上的直线就是我们的解</p> <img src="07image_segmentation.assets/image-20201114120453762.png" alt="image-20201114120453762"></li></ul> <blockquote><p>当直线逼近垂直方向时，a（直线的斜率）会趋于无限大。</p> <p>解决该问题的方法之一是，使用一条直线的极坐标表示：xcosθ + ysinθ = ρ</p> <img src="07image_segmentation.assets/image-20201114120539481.png" alt="image-20201114120539481" style="zoom:67%;"></blockquote> <p>实现流程：</p> <ol><li><p>由于垂直直线的斜率无穷大，则改用极坐标形式。</p> <blockquote><p>参数平面为q,r，对应不是直线而是正弦曲线</p></blockquote></li> <li><p>使用交点累加器，或交点统计直方图，找出相交线段最多的参数空间的点</p></li> <li><p>然后找出该点对应的xy平面的直线线段</p></li></ol> <img src="07image_segmentation.assets/image-20201114120813855.png" alt="image-20201114120813855" style="zoom:67%;"> <h2 id="阈值处理"><a href="#阈值处理" class="header-anchor">#</a> 阈值处理</h2> <p>由于阈值处理直观、实现简单且计算速度快，因此图像阈值处理在图像分割应用中处于核心地位。</p> <h3 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h3> <p>灰度阈值处理基础：</p> <ul><li><p>左图中的灰度直方图对应于图像𝑓(𝑥, 𝑦)，该图像由暗色背景上的较亮物体组成。</p></li> <li><p>从背景中提取物体的一种明显办法是选择一个将这些模式分开的阈值T；然后, 𝑓 (𝑥, 𝑦)&gt; 𝑇的任何点 𝑥, 𝑦 称为一个对象点；否则该点称为背景点。</p></li> <li><p>换句话说，分割后图像𝑔(𝑥, 𝑦)由下式给出：</p> <p><img src="07image_segmentation.assets/image-20201114214120651.png" alt="image-20201114214120651"></p></li> <li><p>当T是一个适用于整个图像的常数时，称为全局阈值处理。当T在一幅图像上改变时，使用可变阈值处理这一术语</p></li></ul> <h3 id="基本全局阈值处理"><a href="#基本全局阈值处理" class="header-anchor">#</a> 基本全局阈值处理</h3> <p>当物体和背景像素的灰度分布十分明显时，可以用适用于整个图像的单个（全局）阈值。</p> <p>在大多数应用中，通常图像之间有较大变化，即使全局阈值是一 种合适的方法，也需要有能对每幅图像自动估计阈值的算法。</p> <p>算法过程：(本质是k-means聚类，k=2)</p> <ol><li><p>为全局阈值T选择一个初始估计值</p></li> <li><p>用单个阈值T分割该图像。这将产生两组像素：𝐺1由灰度值大于T的所有像素组成，𝐺2由所有小于等于T的像素组成</p></li> <li><p>对𝐺1和𝐺2的像素分别计算平均灰度值（均值） <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">m_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">m_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p></li> <li><p>计算一个新的阈值：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo>+</mo><msub><mi>m</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">T=\frac{1}{2}(m_1+m_2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p></li> <li><p>重复步骤（2）到步骤（4），直到连续迭代中的T值间的差小于一个预定 义的参数∆𝑇为止</p></li></ol> <p>参数∆𝑇用于控制迭代的次数。通常， ∆𝑇越大，则算法执行的迭代次数少。图像的平均灰度对于T来说是较好的初始选择</p> <img src="07image_segmentation.assets/image-20201114214445277.png" alt="image-20201114214445277" style="zoom:67%;"> <h3 id="最佳全局阈值处理"><a href="#最佳全局阈值处理" class="header-anchor">#</a> 最佳全局阈值处理</h3> <p>该方法在类间方差最大的情况下是最佳的；完全以在一幅图像的直方图上执行计算为基础。</p> <p>算法过程：</p> <img src="07image_segmentation.assets/image-20201114215423634.png" alt="image-20201114215423634" style="zoom:67%;"> <img src="图像处理.assets/image-20201114215438011.png" alt="image-20201114215438011" style="zoom:67%;"> <h3 id="图像平滑改善全局阈值处理"><a href="#图像平滑改善全局阈值处理" class="header-anchor">#</a> 图像平滑改善全局阈值处理</h3> <p>噪声会将简单的阈值处理问题变为不可解决的问题。当噪声不能 在源头减少，并且阈值处理又是所选择的分割方法时，那么通常能增强性能的一种技术是，在阈值处理之前平滑图像。</p> <p>例如：</p> <img src="07image_segmentation.assets/image-20201114215644469.png" alt="image-20201114215644469" style="zoom:67%;"> <p>如果直方图的波峰是高、窄、对称的，且被深波谷分开，则选取 一个“较好”阈值的机会相当大。改进直方图形状的一种方法是， 仅考虑那些位于或靠近物体和背景间的边缘的像素。</p> <p>算法过程：</p> <ol><li>采用边缘检测，来计算一幅边缘图像，无论是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>梯度的幅度还是拉普拉斯的绝对值均可</li> <li>指定一个阈值T</li> <li>用步骤2中的阈值对步骤1中的图像进行阈值处理，产生一幅二值 图像 𝑔𝑇(𝑥, 𝑦) 。在从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>中选取对应于“强”边缘像素的下一步中， 该图像用做一幅模板图像</li> <li>仅用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 中对应于𝑔𝑇(𝑥, 𝑦)中像素值为1的位置的像素计算直方图</li> <li>用步骤4中直方图全局地分割<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，例如使用Otsu方法</li></ol> <p>若将T设为小于边缘图像的最小值的任何值， 𝑔𝑇(𝑥, 𝑦)将由全1组成， 这意味着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的所有像素将用于计算图像的直方图。习惯以百分比 的形式来指定T值，通常较高（90%），以便在计算中用梯度/拉普拉 斯图像中的较少像素。</p> <img src="07image_segmentation.assets/image-20201114220430713.png" alt="image-20201114220430713" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114220442138.png" alt="image-20201114220442138" style="zoom:67%;"> <h3 id="基本自适应阈值"><a href="#基本自适应阈值" class="header-anchor">#</a> 基本自适应阈值</h3> <p>全局阈值存在一个问题，即不均匀亮度图像无法有效分割。处理办法是将图像进一步细分为子图像，并对不同的子图像使用不同的阈值处理。但是面临新问题是如何将图像进行细分和如何为得到的子图像估计阈值。</p> <img src="07image_segmentation.assets/image-20201114220550235.png" alt="image-20201114220550235" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114220610834.png" alt="image-20201114220610834" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114220713755.png" alt="image-20201114220713755" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201114220723816.png" alt="image-20201114220723816" style="zoom:67%;"> <h2 id="基于区域的分割"><a href="#基于区域的分割" class="header-anchor">#</a> 基于区域的分割</h2> <p>区域生长的基本思想是将具有相似属性的像素集合起来构成区域。</p> <p>具体先对每个需要分割的区域找一个种子像素作为生长的起始点，然后将种子像素周期邻域中与种子像素有相同或相似性质的像素合并到种子像素所在的区域。</p> <p>将这些新像素当作新的种子像素继续进行上面的过程，直到再没有满足条件的像素。</p> <h3 id="区域生长"><a href="#区域生长" class="header-anchor">#</a> 区域生长</h3> <img src="07image_segmentation.assets/image-20201114221418727.png" alt="image-20201114221418727" style="zoom:67%;"> <h3 id="四叉树分解"><a href="#四叉树分解" class="header-anchor">#</a> 四叉树分解</h3> <img src="07image_segmentation.assets/image-20201114221435844.png" alt="image-20201114221435844" style="zoom:67%;"> <h2 id="用形态学分水岭的分割"><a href="#用形态学分水岭的分割" class="header-anchor">#</a> 用形态学分水岭的分割</h2> <p>分水岭也称分水线/水线，将图像看成三维地形表示。</p> <p>基本思想：假设在每个区域的最小值上打一个洞，并且让水通过洞以均匀的速率上升，从 低到高淹没整个地形。当不同汇水盆地中上升的水聚集时，修建一个水坝来阻 止这种聚合。水将达到在水线上只能见到各个水坝的顶部的程度。这些大坝的 边界对应于分水岭的分割线</p> <img src="07image_segmentation.assets/image-20201207150340228.png" alt="image-20201207150340228" style="zoom:80%;"> <h3 id="水坝构建"><a href="#水坝构建" class="header-anchor">#</a> 水坝构建</h3> <img src="07image_segmentation.assets/image-20201207150445985.png" alt="image-20201207150445985" style="zoom:67%;"> <h3 id="分水岭分割算法"><a href="#分水岭分割算法" class="header-anchor">#</a> 分水岭分割算法</h3> <img src="07image_segmentation.assets/image-20201207150516936.png" alt="image-20201207150516936" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201207150533619.png" alt="image-20201207150533619" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201207150552870.png" alt="image-20201207150552870" style="zoom:67%;"> <h3 id="标记的使用"><a href="#标记的使用" class="header-anchor">#</a> 标记的使用</h3> <img src="07image_segmentation.assets/image-20201207150625742.png" alt="image-20201207150625742" style="zoom:67%;"> <img src="07image_segmentation.assets/image-20201207150640209.png" alt="image-20201207150640209" style="zoom:67%;"> <h2 id="基于pde（偏微分方程）的图像分割"><a href="#基于pde（偏微分方程）的图像分割" class="header-anchor">#</a> 基于PDE（偏微分方程）的图像分割</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/AI/DIP/06image_morphology.html" class="prev">
        图像形态学处理
      </a></span> <span class="next"><a href="/AI/DIP/08wavelet_transform.html">
        小波变换
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.02e74a2b.js" defer></script><script src="/assets/js/2.57c6d2f7.js" defer></script><script src="/assets/js/13.41791305.js" defer></script>
  </body>
</html>
